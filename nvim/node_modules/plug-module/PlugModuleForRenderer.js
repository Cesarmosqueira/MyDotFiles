import electron from 'electron';
import PlugModule from './PlugModule';

/* Represent a plug module that used in renderer process */
export default class PlugModuleInRenderer extends PlugModule {
    /**
     * Inject methods to global.plug only when app is ready, same as injectMethodsToGlobal in renderer process
     */
    injectMethodsToGlobalOnReady(...args) {
        this.injectMethodsToGlobal(...args);
    }

    /**
     * Add bootstrappers to module for main process
     * @param {...function} callbacks
     */
    addMainBootstrapper(...callbacks) {}

    /**
     * Add bootstrappers to module for renderer process
     * @param {...function} callbacks
     */
    addRendererBootstrapper(...callbacks) {
        this.addBootstrapper(...callbacks);
    }

    /**
     * Return a method can be run in main and renderer processes accordingly
     * @param {function} callbackForMain
     * @param {function} callbackForRenderer
     * @return {function}
     */
    processMethod(callbackForMain, callbackForRenderer) {
        return callbackForRenderer;
    }

    /**
     * Return a method can be run in main process only
     * @param {function} callback
     * @return {function}
     */
    mainMethod(callback) {
        return () => {};
    }

    /**
     * Return a method can be run in renderer process only
     * @param {function} callback
     * @return {function}
     */
    rendererMethod(callback) {
        return callback;
    }

    /**
     * Create an asynchronous module method
     * @param {string} methodName
     * @param {function} callback
     * @return {function} - A function that request the main process to invoke the callback
     */
    createAsyncMethod(methodName, callback) {
        let isMethodMap = arguments.length === 1 && typeof methodName=== 'object',
            isArgumentsValid = arguments.length === 2 && typeof methodName === 'string';

        if (isMethodMap) {
            this.createAsyncMethods(methodName);
        }
        else {
            const asyncEventName = this.getEventName('async');
            const resolvedEventName = this.getEventName(methodName, 'resolved');
            const rejectedEventName = this.getEventName(methodName, 'rejected');

            const callbackForRenderer = (...args) =>
                new Promise((resolve, reject) => {
                    electron.ipcRenderer.on(resolvedEventName, (event, ...args) => {
                        electron.ipcRenderer.removeListener(resolvedEventName, resolve);
                        resolve(...args);
                    });

                    electron.ipcRenderer.on(rejectedEventName, (event, ...args) => {
                        electron.ipcRenderer.removeListener(rejectedEventName, reject);
                        reject(...args);
                    });

                    electron.ipcRenderer.send(asyncEventName, methodName, ...args);
                });

            this.addMethod(methodName, callbackForRenderer);
        }
    }

    /**
     * Create a synchronous module method
     * @param {string} methodName
     * @param {function} callback
     * @return {function} - A function that request the main process to invoke the callback
     */
    createSyncMethod(methodName, callback) {
        let isMethodMap = arguments.length === 1 && typeof methodName=== 'object',
            isArgumentsValid = arguments.length === 2 && typeof methodName === 'string';

        if (isMethodMap) {
            this.createSyncMethods(methodName);
        }
        else {
            const asyncEventName = this.getEventName('sync');

            const callbackForRenderer = (...args) =>
                electron.ipcRenderer.sendSync(asyncEventName, methodName, ...args);

            return this.addMethod(methodName, callbackForRenderer);
        }
    }

    unload() {
        this.uninjectMethods();
    }

    /**
     * Bootstrap and export only module name to hide other apis
     * Unlike in main process, the module should be immediately bootstrapped in renderer process
     * @param {Object} additionalExports
     * @return {Object} Result
     * @return {string} Result.name - Module name
     * @return {function} Result.bootstrap - Bootstrap function for module
     */
    exportModule(additionalExports) {
        this.bootstrap();

        return Object.assign({
            name: this.name,
            unload: this.unload.bind(this),
        }, this.exportFlags(), additionalExports);
    }
}