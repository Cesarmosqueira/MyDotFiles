import is from 'electron-is';
import _ from 'lodash';
import debug from 'debug';

/** Represent a plug module */
export default class PlugModule {
    /**
     * Create a plug module
     * @constructor
     * @param {string} name="unnamedModule"
     */
    constructor(name) {
        this.name = name || 'unnamedModule';
        this.methods = {};
        this.bootstrappers = [];
        this.injectedMethodNames = [];
        this.flags = {};
    }

    /**
     * Print a message in console
     * @param {string} message
     */
    log(message) {
        debug(`plug:${this.name}`)(message);
    }

    /**
     * Print an error message in console
     * @param {string} message
     */
    errorLog(message) {
        debug(`plug:${this.name}:error`)(message);
    }

    /**
     * Inject methods to global.plug
     * @param {string} [namespace] - If specified, methods will be injected to global.plug.[namespace]
     * @param {...string} [methodNames] - Name of methods to inject
     */
    injectMethodsToGlobal(...args) {
        let namespace,
            methodNames,
            methodsToInject,
            injectPosition = global.plug,
            hasNoArguments = args.length === 0,
            hasOnlyNamespace = args.length === 1 && _.isString(args[0]),
            hasOnlyMethodNames = args.length === 1 && _.isArray(args[0]),
            hasBoth = args.length === 2 && _.isString(args[0]) && _.isArray(args[1]);

        if (hasNoArguments) {
            methodsToInject = this.methods;
        }
        else if (hasOnlyNamespace) {
            namespace = args[0];
        }
        else if (hasOnlyMethodNames) {
            methodNames = args[0];
        }
        else if (hasBoth) {
            namespace = args[0];
            methodNames = args[1];
        }
        else {
            return this.errorLog(`failed to inject methods to global. arguments: ${args}`);
        }

        if (namespace) {
            !_.has(global.plug, namespace) && _.set(global.plug, namespace, {});
            injectPosition = global.plug[namespace];
        }

        methodsToInject = methodNames
            ? _.pickBy(this.methods, (method, name) => _.includes(methodNames, name))
            : this.methods;

        for (const key in methodsToInject) {
            injectPosition[key] = methodsToInject[key];
            this.injectedMethodNames.push(namespace ? `${namespace}.${key}` : key);
        }
    }

    /**
     * Inject a property with getter and setter to global
     * @param {string} path - Namespace and name of property
     * @param {function} get - Getter for property
     * @param {function} [set] - Setter for property
     */
    injectGetterAndSetterToGlobal(path, get, set) {
        const tokens = path.split('.');
        const propertyName = _.last(tokens);
        const injectPath = _.initial(tokens).join('.');
        let injectPosition = global.plug;

        if (injectPath) {
            !_.has(global.plug, injectPath) && _.set(global.plug, injectPath, {});
            injectPosition = _.get(global.plug, injectPath);
        }

        Object.defineProperty(injectPosition, propertyName, {
            get,
            set,
            enumerable: true,
            configurable: true,
        });
    }

    /**
     * Add a method to module
     * @param {string} methodName
     * @param {function} callback
     * @return {function} - Callback
     */
    addMethod(methodName, callback) {
        let isMethodMap = arguments.length === 1 && typeof methodName=== 'object',
            isArgumentsValid = arguments.length === 2 && typeof methodName === 'string';

        if (isMethodMap) {
            return this.addMethods(methodName);
        }
        else if (isArgumentsValid) {
            this.methods[methodName] = callback;
            return callback;
        }
        else {
            return this.errorLog(`failed to add method. arguments: ${arguments}`);
        }
    }

    /**
     * Add methods to module in batch
     * @param {Object.<Method.name, Method.callback>} methodMap - Methods to add
     * @param {string} Method.name
     * @param {function} Method.callback
     */
    addMethods(methodMap) {
        for (const methodName in methodMap) {
            this.addMethod(methodName, methodMap[methodName]);
        };
    }

    /**
     * Add method can be run in main and renderer processes accordingly
     * @param {string} methodName
     * @param {function} callbackForMain
     * @param {function} callbackForRenderer
     * @return {function} - The callback should be used
     */
    addCrossProcessMethod(methodName, callbackForMain, callbackForRenderer) {
        let isMethodsMap = arguments.length === 1 && _.isObject(arguments[0]),
            hasNameAndMethods = arguments.length === 3 && _.isString(arguments[0]);

        if (isMethodsMap) {
            this.addCrossProcessMethods(methodName)
        }
        else if (hasNameAndMethods) {
            const method = is.main() ? arguments[1] : arguments[2];
            this.methods[arguments[0]] = method;

            return method;
        }
        else {
            return this.errorLog(`failed to add cross process method. arguments: ${arguments}`);
        }
    }

    /**
     * Add cross process methods to module in batch
     * @param {Object.<Method.name, Method.callbacks>} methodMap - Methods to add
     * @param {string} Method.name
     * @param {function[].[callbackForMain, callbackForRenderer]} Method.callbacks
     */
    addCrossProcessMethods(methodMap) {
        for (const methodName in methodMap) {
            this.addCrossProcessMethod(methodName, ...methodMap[methodName]);
        };
    }

    /**
     * Remove methods from module
     * @param {...string} methodNames
     */
    removeMethod(...methodNames) {
        for (const methodName of methodNames) {
            delete this.methods[methodName];
        }
    }

    /**
     * Add alias for a method
     * @param {string} methodName
     * @param {...string} aliases
     * @return {function} - The method
     */
    addMethodAlias(methodName, ...aliases) {
        for (const alias of aliases) {
            this.methods[alias] = this.methods[methodName];
        }

        return this.methods[methodName];
    }

    /**
     * Add bootstrappers to module
     * @params {...function} callbacks
     */
    addBootstrapper(...callbacks) {
        this.bootstrappers.push(...callbacks);
    }

    /**
     * Create a module method
     * A module method only runs in main process, but it can be invoked by renderer process through ipc
     * @param {string} methodName
     * @param {function} callback - This callback only runs in main process
     */
    createMethod(methodName, callback) {
        let isMethodMap = arguments.length === 1 && typeof methodName=== 'object',
            isArgumentsValid = arguments.length === 2 && typeof methodName === 'string';

        if (isMethodMap) {
            this.createMethods(methodName);
        }
        else if (isArgumentsValid) {
            this.shouldUseSync(methodName)
                ? this.createSyncMethod(methodName, callback)
                : this.createAsyncMethod(methodName, callback);
        }
        else {
            return this.errorLog(`failed to create method. arguments: ${arguments}`);
        }
    }

    /**
     * Create module methods in batch
     * @param {Object.<Method.name, Method.callback>} methodMap - Methods to create
     * @param {string} Method.name
     * @param {function} Method.callback
     */
    createMethods(methodMap) {
        for (const methodName in methodMap) {
            this.createMethod(methodName, methodMap[methodName]);
        };
    }

    /**
     * Create asynchronous module methods in batch
     * @param {Object.<Method.name, Method.callback>} methodMap - Methods to create
     * @param {string} Method.name
     * @param {function} Method.callback
     */
    createAsyncMethods(methodMap) {
        for (const methodName in methodMap) {
            this.createAsyncMethods(methodName, methodMap[methodName]);
        };
    }

    /**
     * Create synchronous module methods in batch
     * @param {Object.<Method.name, Method.callback>} methodMap - Methods to create
     * @param {string} Method.name
     * @param {function} Method.callback
     */
    createSyncMethods(methodMap) {
        for (const methodName in methodMap) {
            this.createSyncMethods(methodName, methodMap[methodName]);
        };
    }

    /**
     * Return whether should use synchronous method based on method name
     * @param {string} methodName
     * @return {boolean}
     */
    shouldUseSync(methodName) {
        return _.startsWith(methodName, 'get')
            || _.startsWith(methodName, 'is')
            || _.startsWith(methodName, 'has')
            || _.startsWith(methodName, 'not');
    }

    /**
     * Get a unique event name based on module and method name
     * @param {string} methodName
     * @param {string} [suffix]
     * @return {string}
     */
    getEventName(...suffix) {
        return `__PLUG_MODULE__${[this.name, ...suffix].map(v => _.snakeCase(v)).join('__')}__`.toUpperCase();
    }

    /**
     * Run all bootstrappers registered
     * @param {...*} [args] - Arguments passed to bootstrappers
     * @return {Promise[]} - Array of returned promises from bootstrappers with other results removed
     */
    bootstrap(...args) {
        if (this.bootstrappers.length) {
            this.log(`bootstrapping....`);
        }

        return _(this.bootstrappers)
            .map(bootstrapper => bootstrapper(...args))
            .compact()
            .filter(result => result.then)
            .value();
    }

    /**
     * Uninject all the methods injected to global.plug
     */
    uninjectMethods() {
        for (const key of this.injectedMethodNames) {
            _.unset(global, `plug.${key}`);
        }
    }

    /**
     * Add a flag
     * @param {string} flagName
     * @param {boolean | string | number} [defaultValue]
     * @param {function} [defaultValue] - This function will be invoked when the flag setter is invoked
     */
    addFlag(flagName, defaultValue, defaultCallback) {
        const isFlagMap = _.isObject(flagName);
        const hasFlagName = !!flagName;

        if (isFlagMap) {
            this.addFlags(flagName);
        }
        else if (hasFlagName) {
            if (_.isFunction(defaultValue)) {
                defaultCallback = defaultValue;
            }

            this.flags[flagName] = { value: defaultValue, callback: defaultCallback };
        }
        else {
            return this.errorLog(`failed to set flag. arguments: ${arguments}`);
        }
    }

    /**
     * Add flags in batch
     * @param {object} flagMap
     */
    addFlags(flagMap) {
        for (const flagName in flagMap) {
            this.addFlag(flagName, flagMap[flagName].value, flagMap[flagName].callback);
        }
    }

    /**
     * Get flag value
     * @param {string} flagName
     * @return {boolean | string | number}
     */
    getFlag(flagName) {
        return _.get(this.flags, `${flagName}.value`);
    }

    /**
     * Remove flags by name
     * @param {string} ...flagNames
     */
    removeFlag(...flagNames) {
        for (const name of flagNames) {
            delete this.flags[name];
        }
    }

    /**
     * Export flag setters
     */
    exportFlags() {
        const flags = this.flags;

        return _.mapValues(flags, ({ callback }, flagName) =>
            function(newValue) {
                const oldValue = _.get(flags, `${flagName}.value`);
                _.set(flags, `${flagName}.value`, _.isUndefined(newValue) ? true : newValue);
                callback && callback(newValue, oldValue);

                return this;
            }
        );
    }
}