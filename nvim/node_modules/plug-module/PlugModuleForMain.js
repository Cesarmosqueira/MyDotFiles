import electron from 'electron';
import PlugModule from './PlugModule';

/* Represent a plug module that used in main process */
export default class PlugModuleForMain extends PlugModule {
    /**
     * Create a plug module
     * @constructor
     * @param {string} name="unnamedModule"
     */
    constructor(name) {
        super(name);

        this.setupIpc();
    }

    /**
     * Setup IPC listeners to handle events from renderer processes
     */
    setupIpc() {
        this.asyncEventName = this.getEventName('async');
        this.syncEventName = this.getEventName('sync');
        electron.ipcMain.on(this.asyncEventName, this.handleAsyncEvent.bind(this));
        electron.ipcMain.on(this.syncEventName, this.handleSyncEvent.bind(this));
    }

    /**
     * Handle async event to invoke method from renderer process
     * @param {object} event - Native event from Electron
     * @param {string} methodName
     */
    handleAsyncEvent(event, methodName, ...args) {
        try {
            const resolvedEventName = this.getEventName(methodName, 'resolved');
            const rejectedEventName = this.getEventName(methodName, 'rejected');

            this.methods[methodName](...args)
                .then((...args) => {
                    event.sender.send(resolvedEventName, ...args);
                })
                .catch((...args) => {
                    event.sender.send(rejectedEventName, ...args);
                });
        }
        catch(error) {}
    }

    /**
     * Handle sync event to invoke method from renderer process
     * @param {object} event - Native event from Electron
     * @param {string} methodName
     */
    handleSyncEvent(event, methodName, ...args) {
        event.returnValue = this.methods[methodName](...args);
    }

    /**
     * Inject methods to global.plug only when app is ready
     */
    injectMethodsToGlobalOnReady(...args) {
        electron.app.on('ready', () => this.injectMethodsToGlobal(...args));
    }

    /**
     * Add bootstrappers to module for main process
     * @param {...function} callbacks
     */
    addMainBootstrapper(...callbacks) {
        this.addBootstrapper(...callbacks);
    }

    /**
     * Add bootstrappers to module for renderer process
     * @param {...function} callbacks
     */
    addRendererBootstrapper(...callbacks) {}

    /**
     * Return a method can be run in main and renderer processes accordingly
     * @param {function} callbackForMain
     * @param {function} callbackForRenderer
     * @return {function}
     */
    processMethod(callbackForMain, callbackForRenderer) {
        return callbackForMain;
    }

    /**
     * Return a method can be run in main process only
     * @param {function} callback
     * @return {function}
     */
    mainMethod(callback) {
        return callback;
    }

    /**
     * Return a method can be run in renderer process only
     * @param {function} callback
     * @return {function}
     */
    rendererMethod(callback) {
        return () => {};
    }

    /**
     * Create an asynchronous module method
     * @param {string} methodName
     * @param {function} callback - The callback can return a promise
     * @return {function} - Callback
     */
    createAsyncMethod(methodName, callback) {
        let isMethodMap = arguments.length === 1 && typeof methodName=== 'object',
            isArgumentsValid = arguments.length === 2 && typeof methodName === 'string';

        if (isMethodMap) {
            this.createAsyncMethods(methodName);
        }
        else {
            return this.addMethod(methodName, callback);
        }
    }

    /**
     * Create a synchronous module method
     * @param {string} methodName
     * @param {function} callback - The callback must return a value, otherwise the app will hang
     * @return {function} - Callback
     */
    createSyncMethod(methodName, callback) {
        let isMethodMap = arguments.length === 1 && typeof methodName=== 'object',
            isArgumentsValid = arguments.length === 2 && typeof methodName === 'string';

        if (isMethodMap) {
            this.createSyncMethods(methodName);
        }
        else {
            return this.addMethod(methodName, callback);
        }
    }

    /**
     * Unload the module
     */
    unload() {
        electron.ipcMain.removeListener(this.asyncEventName, this.handleAsyncEvent);
        electron.ipcMain.removeListener(this.syncEventName, this.handleSyncEvent);

        this.uninjectMethods();
    }

    /**
     * Export only module name and bootstrap function to hide other apis
     * In main process, the modules are bootstrapped in plug, therefore the bootstrap function is exported
     * @param {Object} additionalExports
     * @return {Object} Result
     * @return {string} Result.name - Module name
     * @return {function} Result.bootstrap - Bootstrap function for module
     */
    exportModule(additionalExports) {
        return Object.assign({
            name: this.name,
            bootstrap: this.bootstrap.bind(this),
            unload: this.unload.bind(this),
        }, this.exportFlags(), additionalExports);
    }
}