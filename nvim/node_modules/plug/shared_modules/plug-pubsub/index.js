import Emitter from 'events';

const emitters = {};

export class Pubsub {
    /**
     * Create a pubsub
     * @constructor
     * @param {string} name
     */
    constructor(name) {
        this.name = name;

        if (!emitters[name]) {
            emitters[name] = new Emitter();
        }
    }

    /**
     * Subscribe an event
     * @param {string} eventName
     * @param {function} callback
     */
    subscribe(eventName, callback) {
        emitters[this.name].on(eventName, callback);
    }

    /**
     * Subscribe an event, the callback will only be invoked once
     * @param {string} eventName
     * @param {function} callback
     */
    once(eventName, callback) {
        emitters[this.name].once(eventName, callback);
    }

    /**
     * Unsubscribe an event
     * @param {string} eventName
     * @param {function} [callback] - If unprovided, remove all listeners
     */
    unsubscribe(eventName, callback) {
        if (isHierarchical(eventName)) {
            emitters[this.name].eventNames().forEach(name => {
                if (matchHierarchicalName(eventName, name)) {
                    if (callback) {
                        emitters[this.name].removeListener(name, callback);
                    } else {
                        emitters[this.name].removeAllListeners([name]);
                    }
                }
            });
        }
        else {
            if (callback) {
                emitters[this.name].removeListener(eventName, callback);
            } else {
                emitters[this.name].removeAllListeners([eventName]);
            }
        }
    }

    /**
     * Publish an event
     * @param {string} eventName
     * @param {*} [...args]
     */
    publish(eventName, ...args) {
        return new Promise((resolve, reject) => {
            const event = {
                name: eventName,
                resolve,
                reject,
            };

            if (isHierarchical(eventName)) {
                getHierarchicalNames(eventName).forEach(name => {
                    emitters[this.name].emit(name, event, ...args);
                });
            }
            else {
                emitters[this.name].emit(eventName, event, ...args);
            }
        });
    }

    /**
     * Clear all subscriptions
     */
    clearAllSubscriptions() {
        emitters[this.name].removeAllListeners();
    }
}

export class PubsubWithNativeEvent extends Pubsub {
    /**
     * Publish an event. Native event will be merged into event and pass to listeners
     * @param {string} eventName
     * @param {Object} nativeEvent
     * @param {*} [...args]
     */
    publish(eventName, nativeEvent, ...args) {
        return new Promise((resolve, reject) => {
            const event = Object.assign({
                name: eventName,
                resolve,
                reject,
            }, nativeEvent);

            if (isHierarchical(eventName)) {
                getHierarchicalNames(eventName).forEach(name => {
                    emitters[this.name].emit(name, event, ...args);
                });
            }
            else {
                emitters[this.name].emit(eventName, event, ...args);
            }
        });
    }
}

function isHierarchical(value) {
    return value.split('.').length > 1;
}

function getHierarchicalNames(value) {
    let temp = '';

    return value.split('.').map((token, index) => {
        temp += (index ? '.' : '') + token;
        return temp;
    }).reverse();
}

function matchHierarchicalName(eventName, compareName) {
    return compareName === eventName || compareName.startsWith(`${eventName}.`);
}