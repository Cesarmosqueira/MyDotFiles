import Emitter from 'events';
import _ from 'lodash';

const stores = {};

/* Represent a store that can be accessed from any processes */
export class Store {
    /**
     * Create a store
     * @constructor
     * @param {string} name
     */
    constructor(name) {
        this.name = name;
        stores[name] = stores[name] || {};
    }

    /**
     * Get the value at path of store. If undefined, the defaultValue is returned in its place.
     * @param {string[] || string} path
     * @param {*} [defaultValue]
     */
    get(path, defaultValue) {
        return _.isUndefined(path)
            ? _.cloneDeep(stores[this.name])
            : _.get(stores[this.name], path, defaultValue);
    }

    /**
     * Sets the value at path of store
     * @param {string[] || string} path
     * @param {*} value
     */
    set(path, value) {
        const isDataMap = arguments.length === 1 && _.isObject(path);

        if (isDataMap) {
            this.setInBatch(path)
        }
        else {
            const oldStore = _.cloneDeep(stores[this.name]);
            _.set(stores[this.name], path, value);
            plug.emit(`plug.store.${this.name}`, {}, stores[this.name], oldStore);
        }
    }

    /**
     * Set data in batch
     * @param {Object.<Data.path, Data.value>}
     * @param {string} Data.path
     * @param {*} Data.value
     */
    setInBatch(dataMap) {
        for (const path in dataMap) {
            this.set(path, dataMap[path]);
        }
    }

    /**
     * Remove the property at path of store
     * @param {string[] || string} path
     * @return {boolean} - Return true if the property is deleted
     */
    delete(path) {
        const oldStore = _.cloneDeep(stores[this.name]);
        const result = _.unset(stores[this.name], path);
        plug.emit(`plug.store.${this.name}`, {}, stores[this.name], oldStore);

        return result;
    }

    /**
     * Check if path is a direct property of store
     * @param {string[] || string} path
     * @return {boolean}
     */
    has(path) {
        return _.hasIn(stores[this.name], path);
    }

    /**
     * Remove all data from store
     */
    clear() {
        const newStore = {};

        plug.emit(`plug.store.${this.name}`, {}, newStore, stores[this.name]);
        stores[this.name] = newStore;
    }

    /**
     * Add a listener to be invoked when the store is changed
     * @param {string} [path]
     * @param {function} callback
     * @return {Object[]} - Old value and new value
     */
    onChange(path, callback) {
        if (_.isFunction(path)) {
            callback = path;
            path = false;
        }

        plug.on(`plug.store.${this.name}`, (event, newStore, oldStore) => {
            if (path) {
                const newValue = _.get(newStore, path);
                const oldValue = _.get(oldStore, path);
                const hasDataInPath = !_.isUndefined(oldValue) || !_.isUndefined(newValue);
                const isDataChanged = !_.isEqual(newValue, oldValue);

                if (hasDataInPath && isDataChanged) {
                    callback(newValue, oldValue);
                }
            }
            else {
                callback(newStore, oldStore);
            }
        });
    }

    /**
     * Get the size of store
     */
    get size() {
        return Object.keys(stores[this.name]).length;
    }

    /**
     * Get the whole store
     * @return {Object}
     */
    get store() {
        return _.cloneDeep(stores[this.name]);
    }

    /**
     * Replace the whole store with given data.
     * @param {Object} data
     */
    set store(data) {
        plug.emit(`plug.store.${this.name}`, {}, data, stores[this.name]);
        stores[this.name] = data;
    }
}