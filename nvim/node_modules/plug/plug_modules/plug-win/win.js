import electron from 'electron';
import debug from 'debug';
import { requireShared } from '../plug-utils';
import preprocessOptions from './optionsPreprocessor';
import postprocessOptions from './optionsPostprocessor';
import postprocessNewWindow from './newWindowPostprocessor';

const log = debug('plug:win');
const error = debug('plug:win:error');
const BrowserWindow = plug.isMain ? electron.BrowserWindow : electron.remote.BrowserWindow;
const { Store } = requireShared('plug-store');
const windowStore = new Store();

/**
 * Get window by name
 * @param {string} name
 * @return {Object} - Window instance
 */
function getWindow(name) {
    return windowStore.get(name);
}

/**
 * Get all windows
 * @return {Object[]} - Array of window instances
 */
function getAllWindows() {
    return Object.values(windowStore.get());
}

/**
 * Get focused window if used in main process, get current window if used in renderer process
 * @return {Object} - Window instance
 */
function getCurrentWindow() {
    return plug.isMain
        ? getFocusedWindow()
        : electron.remote.getCurrentWindow();
}

/**
 * Get focused window
 * @return {Object} - Window instance
 */
function getFocusedWindow() {
    return BrowserWindow.getFocusedWindow();
}

/**
 * Create a new window
 * @param {string} name
 * @param {Options} options - see https://electron.atom.io/docs/api/browser-window/#new-browserwindowoptions
 */
function createWindow(name, options) {
    if (windowStore.has(name)) {
        return error('A window with this name already exists!');
    }

    log(`creating window: "${name}"`);

    options = _.defaults({ _name: name }, options);
    preprocessOptions(options);

    const newWin = new BrowserWindow(options);
    newWin.loadURL(options.url);

    postprocessOptions(newWin, options, windowStore);
    postprocessNewWindow(newWin, name, windowStore)

    return newWin;
}

export default {
    getWindow,
    getAllWindows,
    getCurrentWindow,
    getFocusedWindow,
    createWindow,
};